"use client";

import { useCallback, useState, useRef, useEffect } from "react";
import { StoryboardData } from "@/lib/types";

/** Get real pixel dimensions of a base64 / data-URL image */
const getImageDimensions = (
  dataUrl: string
): Promise<{ width: number; height: number }> =>
  new Promise((resolve) => {
    const img = new Image();
    img.onload = () =>
      resolve({ width: img.naturalWidth, height: img.naturalHeight });
    img.onerror = () => resolve({ width: 1, height: 1 });
    img.src = dataUrl;
  });

interface ExportButtonProps {
  targetId: string;
  filename: string;
  storyboard: StoryboardData;
}

export default function ExportButton({
  targetId,
  filename,
  storyboard,
}: ExportButtonProps) {
  const [exporting, setExporting] = useState<string | null>(null);
  const [open, setOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handler = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        setOpen(false);
      }
    };
    document.addEventListener("mousedown", handler);
    return () => document.removeEventListener("mousedown", handler);
  }, []);

  const exportPNG = useCallback(async () => {
    setExporting("png");
    setOpen(false);
    try {
      const { default: html2canvas } = await import("html2canvas");
      const element = document.getElementById(targetId);
      if (!element) return;
      const canvas = await html2canvas(element, {
        scale: 2,
        backgroundColor: "#fafafa",
        useCORS: true,
      });
      const link = document.createElement("a");
      link.download = `${filename}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    } catch (error) {
      console.error("PNG export failed:", error);
    } finally {
      setExporting(null);
    }
  }, [targetId, filename]);

  const exportPDF = useCallback(async () => {
    setExporting("pdf");
    setOpen(false);
    try {
      const { default: jsPDF } = await import("jspdf");
      const doc = new jsPDF({
        orientation: "landscape",
        unit: "mm",
        format: "a4",
      });
      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();
      const margin = 12;

      // Title page
      doc.setFontSize(24);
      doc.setFont("helvetica", "bold");
      doc.text(storyboard.title, pageW / 2, 50, { align: "center" });
      doc.setFontSize(14);
      doc.setFont("helvetica", "normal");
      doc.setTextColor(100);
      doc.text(
        `Product: ${storyboard.productName}`,
        pageW / 2,
        65,
        { align: "center" }
      );
      doc.text(
        `Duration: ${storyboard.duration}  |  Frames: ${storyboard.totalFrames}`,
        pageW / 2,
        75,
        { align: "center" }
      );
      doc.setFontSize(10);
      doc.text("Generated by Storyboard Generator", pageW / 2, pageH - 15, {
        align: "center",
      });

      // Frame pages
      for (const frame of storyboard.frames) {
        doc.addPage();
        doc.setTextColor(0);

        doc.setFontSize(16);
        doc.setFont("helvetica", "bold");
        doc.text(`Scene ${frame.sceneNumber}`, margin, 18);
        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        doc.setTextColor(100);
        doc.text(frame.timestamp, pageW - margin, 18, { align: "right" });

        const maxImgW = 90;
        const maxImgH = pageH - 24 - margin - 4;
        let imgWidth = maxImgW;
        let imgHeight = maxImgH;
        let textX = margin + maxImgW + 8;

        if (frame.imageUrl) {
          try {
            const dims = await getImageDimensions(frame.imageUrl);
            const ratio = dims.width / dims.height;
            // Fit within max bounds while preserving aspect ratio
            if (ratio >= maxImgW / maxImgH) {
              imgWidth = maxImgW;
              imgHeight = maxImgW / ratio;
            } else {
              imgHeight = maxImgH;
              imgWidth = maxImgH * ratio;
            }
            doc.addImage(frame.imageUrl, "PNG", margin, 24, imgWidth, imgHeight);
            textX = margin + imgWidth + 8;
          } catch {
            textX = margin;
          }
        } else {
          textX = margin;
        }

        const textW = pageW - textX - margin;
        let y = 28;

        const addSection = (label: string, content: string) => {
          doc.setFontSize(8);
          doc.setFont("helvetica", "bold");
          doc.setTextColor(100);
          doc.text(label.toUpperCase(), textX, y);
          y += 4;
          doc.setFontSize(10);
          doc.setFont("helvetica", "normal");
          doc.setTextColor(0);
          const lines = doc.splitTextToSize(content, textW);
          doc.text(lines, textX, y);
          y += lines.length * 4.5 + 4;
        };

        addSection("Scene Description", frame.sceneDescription);
        addSection("Dialogue / Narration", frame.dialogue);
        addSection("Camera Work", frame.cameraWork);
        addSection("Sound / BGM", frame.sound);
        addSection("Direction Notes", frame.directionNotes);
      }

      doc.save(`${filename}.pdf`);
    } catch (error) {
      console.error("PDF export failed:", error);
    } finally {
      setExporting(null);
    }
  }, [filename, storyboard]);

  const exportPPTX = useCallback(async () => {
    setExporting("pptx");
    setOpen(false);
    try {
      const PptxGenJS = (await import("pptxgenjs")).default;
      const pptx = new PptxGenJS();
      pptx.layout = "LAYOUT_WIDE";

      // Title slide
      const titleSlide = pptx.addSlide();
      titleSlide.addText(storyboard.title, {
        x: 0.5, y: 1.5, w: 12.3, h: 1.2,
        fontSize: 32, bold: true, align: "center", color: "1a1a1a",
      });
      titleSlide.addText(
        `Product: ${storyboard.productName}  |  Duration: ${storyboard.duration}  |  Frames: ${storyboard.totalFrames}`,
        { x: 0.5, y: 3.0, w: 12.3, h: 0.5, fontSize: 14, align: "center", color: "666666" }
      );
      titleSlide.addText("Generated by Storyboard Generator", {
        x: 0.5, y: 6.8, w: 12.3, h: 0.3, fontSize: 9, align: "center", color: "999999",
      });

      // Frame slides
      for (const frame of storyboard.frames) {
        const slide = pptx.addSlide();

        slide.addText(`Scene ${frame.sceneNumber}`, {
          x: 0.4, y: 0.2, w: 4, h: 0.4,
          fontSize: 18, bold: true, color: "1a1a1a",
        });
        slide.addText(frame.timestamp, {
          x: 8, y: 0.2, w: 5, h: 0.4,
          fontSize: 12, align: "right", color: "666666",
        });

        const pptMaxW = 4.5;
        const pptMaxH = 5.5;
        let actualImgW = pptMaxW;
        let textXOffset = 5.2;

        if (frame.imageUrl) {
          try {
            const dims = await getImageDimensions(frame.imageUrl);
            const ratio = dims.width / dims.height;
            let imgW = pptMaxW;
            let imgH = pptMaxW / ratio;
            if (imgH > pptMaxH) {
              imgH = pptMaxH;
              imgW = pptMaxH * ratio;
            }
            slide.addImage({ data: frame.imageUrl, x: 0.4, y: 0.8, w: imgW, h: imgH });
            actualImgW = imgW;
            textXOffset = 0.4 + actualImgW + 0.3;
          } catch {
            textXOffset = 0.4;
          }
        } else {
          textXOffset = 0.4;
        }

        const textX = textXOffset;
        const textW = 13.3 - textX - 0.3;
        let textY = 0.8;

        const addText = (label: string, content: string) => {
          slide.addText(label.toUpperCase(), {
            x: textX, y: textY, w: textW, h: 0.25,
            fontSize: 8, bold: true, color: "999999",
          });
          textY += 0.25;
          slide.addText(content, {
            x: textX, y: textY, w: textW, h: 0.7,
            fontSize: 11, color: "1a1a1a", valign: "top", shrinkText: true,
          });
          textY += 0.75;
        };

        addText("Scene Description", frame.sceneDescription);
        addText("Dialogue / Narration", frame.dialogue);
        addText("Camera Work", frame.cameraWork);
        addText("Sound / BGM", frame.sound);
        addText("Direction Notes", frame.directionNotes);
      }

      await pptx.writeFile({ fileName: `${filename}.pptx` });
    } catch (error) {
      console.error("PPTX export failed:", error);
    } finally {
      setExporting(null);
    }
  }, [filename, storyboard]);

  const isExporting = exporting !== null;

  return (
    <div className="relative" ref={menuRef}>
      <button
        onClick={() => setOpen(!open)}
        disabled={isExporting}
        className="px-5 py-2.5 bg-accent text-white text-[13px] font-medium rounded-lg hover:opacity-85 transition-opacity disabled:opacity-40 flex items-center gap-2"
      >
        {isExporting ? `Exporting ${exporting?.toUpperCase()}...` : "Export \u25BE"}
      </button>

      {open && !isExporting && (
        <div className="absolute right-0 top-full mt-1 bg-card border border-border rounded-lg shadow-lg overflow-hidden z-50 min-w-[180px]">
          <button
            onClick={exportPNG}
            className="w-full px-4 py-2.5 text-left text-[13px] text-text hover:bg-bg transition-colors"
          >
            PNG Image
          </button>
          <button
            onClick={exportPDF}
            className="w-full px-4 py-2.5 text-left text-[13px] text-text hover:bg-bg transition-colors border-t border-border"
          >
            PDF Document
          </button>
          <button
            onClick={exportPPTX}
            className="w-full px-4 py-2.5 text-left text-[13px] text-text hover:bg-bg transition-colors border-t border-border"
          >
            PowerPoint (.pptx)
          </button>
        </div>
      )}
    </div>
  );
}
